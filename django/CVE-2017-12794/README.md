**Contributor**
- [이건우(Cheshire1225)](https://github.com/Cheshire1225)

# Django debug page XSS 취약성 (CVE-2017-12794) 분석

Django가 새 버전 1.11을 출시했습니다.5. 500페이지에 존재할 수 있는 XSS 취약점을 수정했습니다. 이 기사는 취약점의 원리와 재현, 그리고 저의 짧은 리뷰를 설명합니다.

## 0x01 패치 분석

공식 설명은 500페이지에 나오는 버그이기 때문에, 우리가 중점적으로 주목하는 것은 `django/views/debug.py`。

Github에 Django의 저장소가 있으니 다운로드 받아 1.11.4와 1.11.5 비교합니다:

```bash
git clone https://github.com/django/django.git
cd django
git diff 1.11.4 1.11.5 django/views/debug.py
```

![sp170908_035017](img/django/sp170908_035017.png)

외부에서 전역 이스케이프를 닫은 다음 두 곳에 강제 이스케이프가 추가되었음을 알 수 있습니다. 그렇다면 이 위치에서 취약점이 발생한 것 같습니다.

## 0x02 코드 분석

이 두 출력점을 작동시키려면 이 if문으로 들어가야 합니다:`{% ifchanged frame.exc_cause %}{% if frame.exc_cause %}`。

일단 정상적인 상황에서 이 자리는 어떤 용도로 쓰이는지, 즉 기능점이 무엇인지 한번 생각해보도록 하겠습니다.

다수년 경력의 Django 개발자로서, 위 사진에서 강조된 문장 `The above exception was the direct cause of the following exception:`을 보면 주로 데이터베이스 예외가 발생했을 때 이와 같은 오류 메시지가 표시된다는 기억이 있습니다.

간단한 테스트를 할 수 있습니다. Django 명령줄에서 username이 phith0n인 사용자를 만들고 username이 phith0n인 사용자를 다시 만들면 `IntegrityError` 예외가 발생합니다.

![sp170908_040738](img/django/sp170908_040738.png)

위 사진을 보면, 이는 데이터베이스의 Unique 예외가 발생했기 때문입니다.

Django는 왜 이러한 비정상적인 메커니즘을 도입했을까요? 이는 Django의 모델이 궁극적으로 데이터베이스를 작동하고, Django가 데이터베이스에서 어떤 오류가 발생할지 100% 예측할 수 없기 때문에 개발자가 SQL 오류를 디버깅할 수 있도록 하기 위한 것입니다. 그런 다음 개발자가 어떤 작업이 데이터베이스 예외를 트리거했는지 빠르게 찾으려면 두 개의 예외 역추적 스택을 함께 연결해야 합니다.

`django/db/utils.py`의 `__exit__` 함수 코드를 살펴보겠습니다.

```python
def __exit__(self, exc_type, exc_value, traceback):
if exc_type is None:
return
for dj_exc_type in (
DataError,
OperationalError,
IntegrityError,
InternalError,
ProgrammingError,
NotSupportedError,
DatabaseError,
InterfaceError,
Error,
):
db_exc_type = getattr(self.wrapper.Database, dj_exc_type.__name__)
if issubclass(exc_type, db_exc_type):
dj_exc_value = dj_exc_type(*exc_value.args)
dj_exc_value.__cause__ = exc_value
if not hasattr(exc_value, '__traceback__'):
exc_value.__traceback__ = traceback
# # Only set the 'errors_occurred' flag for errors that may make
# # the connection unusable.
if dj_exc_type not in (DataError, IntegrityError):
self.wrapper.errors_occurred = True
six.reraise(dj_exc_type, dj_exc_value, traceback)
```

여기서 `exc_type`은 예외입니다. 해당 유형이 `DataError,OperationalError,IntegrityError,InternalError, ProgrammingError,NotSupportedError,DatabaseError,InterfaceError,Error` 중 하나인 경우 동일한 유형의 새 예외가 발생하고 해당 `__cause__` 및 `__traceback__`은 `exc_value` 및 이때 컨텍스트를 추적합니다.

`exc_value`는 이전 예외에 대한 설명이고, `traceeback`은 이전 이상에 대한 역추적 스택입니다.이 함수는 사실 이전 예외과 현재 새로운 예외을 연결합니다.

마지막으로 500페이지에서 `_cause_`가 출력됩니다.

## 0x03 취약점 구현

테스트 후 Postgres 데이터베이스를 사용하고 예외를 트리거할 때 psycopg2가 필드 이름과 필드 값을 모두 발생시키는 것으로 나타났습니다. 그런 다음 필드 값에 우리가 제어할 수 있는 문자열이 포함되어 있고 0x02에서 언급한 대로 이 문자열은 실제로 `__cause__`로 설정되어 최종적으로 페이지에 표시됩니다.

그래서 우리는 다음과 같은 장면이 있다고 가정합니다.

1. 사용자 등록 페이지, 사용자 이름을 확인하지 못했습니다.
2. `<script>alert(1)</script>`라는 사용자 이름을 가진 사용자 등록하기
3. `<script>alert(1)</script>`라는 사용자 이름을 가진 사용자를 다시 등록합니다.
4. duplicate key 예외를 발생시켜 XSS 취약성을 초래합니다

위 프로세스를 vulhub용 환경으로 구성했습니다:https://github.com/phith0n/vulhub/tree/master/django/CVE-2017-12794

컴파일 및 부팅 환경:

```
docker compose up -d
```

`http://your-ip:8000/create_user/?username=<script> alert(1) </script>` 에 접속하여 성공적으로 사용자를 생성했습니다. `http:///your-ip:8000 /create_user /?username=<script> alert(1) < /script>` 에 접속하여 예외를 발생시킵니다:
